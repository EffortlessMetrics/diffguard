{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ConfigFile",
  "description": "The on-disk configuration file.",
  "type": "object",
  "properties": {
    "defaults": {
      "$ref": "#/$defs/Defaults",
      "default": {
        "base": "origin/main",
        "diff_context": 0,
        "fail_on": "error",
        "head": "HEAD",
        "max_findings": 200,
        "scope": "added"
      }
    },
    "includes": {
      "description": "Include other config files. Paths are relative to this config file's directory.\nRules are merged: later definitions override earlier ones by rule ID.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "rule": {
      "type": "array",
      "default": [],
      "items": {
        "$ref": "#/$defs/RuleConfig"
      }
    }
  },
  "$defs": {
    "Defaults": {
      "type": "object",
      "properties": {
        "base": {
          "type": [
            "string",
            "null"
          ]
        },
        "diff_context": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0
        },
        "fail_on": {
          "anyOf": [
            {
              "$ref": "#/$defs/FailOn"
            },
            {
              "type": "null"
            }
          ]
        },
        "head": {
          "type": [
            "string",
            "null"
          ]
        },
        "max_findings": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0
        },
        "scope": {
          "anyOf": [
            {
              "$ref": "#/$defs/Scope"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "FailOn": {
      "type": "string",
      "enum": [
        "error",
        "warn",
        "never"
      ]
    },
    "MatchMode": {
      "oneOf": [
        {
          "description": "Emit a finding when at least one pattern matches (default behavior).",
          "type": "string",
          "const": "any"
        },
        {
          "description": "Emit a finding when none of the patterns match within the scoped file.",
          "type": "string",
          "const": "absent"
        }
      ]
    },
    "RuleConfig": {
      "type": "object",
      "properties": {
        "context_patterns": {
          "description": "Optional context patterns that must match near a primary match.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "context_window": {
          "description": "Context search window (lines before/after the matched line).\nIf omitted and `context_patterns` are set, a default of 3 is used.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0
        },
        "depends_on": {
          "description": "Rule dependencies. This rule is only evaluated in files where all dependencies matched.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "escalate_patterns": {
          "description": "Optional patterns that escalate severity when found near a match.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "escalate_to": {
          "description": "Escalation target severity. Defaults to `error` when escalation patterns match.",
          "anyOf": [
            {
              "$ref": "#/$defs/Severity"
            },
            {
              "type": "null"
            }
          ]
        },
        "escalate_window": {
          "description": "Escalation search window (lines before/after the matched line).\nIf omitted and `escalate_patterns` are set, a default of 0 (same line) is used.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0
        },
        "exclude_paths": {
          "description": "Exclude path globs.",
          "type": "array",
          "default": [],
          "items": {
            "type": "string"
          }
        },
        "help": {
          "description": "Optional help text explaining how to fix violations.",
          "type": [
            "string",
            "null"
          ]
        },
        "id": {
          "type": "string"
        },
        "ignore_comments": {
          "type": "boolean",
          "default": false
        },
        "ignore_strings": {
          "type": "boolean",
          "default": false
        },
        "languages": {
          "description": "Optional language tags (e.g. \"rust\"). Empty means \"all\".",
          "type": "array",
          "default": [],
          "items": {
            "type": "string"
          }
        },
        "match_mode": {
          "description": "Matching mode:\n- `any` (default): emit when patterns match\n- `absent`: emit when patterns do not match in the scoped file",
          "$ref": "#/$defs/MatchMode"
        },
        "message": {
          "type": "string"
        },
        "multiline": {
          "description": "Enable multi-line matching across consecutive scoped lines.",
          "type": "boolean"
        },
        "multiline_window": {
          "description": "Number of consecutive scoped lines to include in a multiline window.\nIf omitted and `multiline=true`, a default of 2 lines is used.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0
        },
        "paths": {
          "description": "Include path globs. Empty means \"all\".",
          "type": "array",
          "default": [],
          "items": {
            "type": "string"
          }
        },
        "patterns": {
          "description": "One or more regex patterns.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "severity": {
          "$ref": "#/$defs/Severity"
        },
        "tags": {
          "description": "Tags for grouping/filtering rules (e.g., \"debug\", \"security\", \"style\").",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "test_cases": {
          "description": "Test cases for validating this rule.",
          "type": "array",
          "items": {
            "$ref": "#/$defs/RuleTestCase"
          }
        },
        "url": {
          "description": "Optional URL with more information about the rule.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "id",
        "severity",
        "message",
        "patterns"
      ]
    },
    "RuleTestCase": {
      "description": "A test case for validating a rule's behavior.",
      "type": "object",
      "properties": {
        "description": {
          "description": "Optional: description of what this test case validates.",
          "type": [
            "string",
            "null"
          ]
        },
        "ignore_comments": {
          "description": "Optional: override ignore_comments for this test case.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "ignore_strings": {
          "description": "Optional: override ignore_strings for this test case.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "input": {
          "description": "The input line to test against the rule.",
          "type": "string"
        },
        "language": {
          "description": "Optional: specify a language for preprocessing (e.g., \"rust\", \"python\").",
          "type": [
            "string",
            "null"
          ]
        },
        "should_match": {
          "description": "Whether the rule should match this input.",
          "type": "boolean"
        }
      },
      "required": [
        "input",
        "should_match"
      ]
    },
    "Scope": {
      "type": "string",
      "enum": [
        "added",
        "changed",
        "modified",
        "deleted"
      ]
    },
    "Severity": {
      "type": "string",
      "enum": [
        "info",
        "warn",
        "error"
      ]
    }
  }
}